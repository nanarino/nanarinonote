# 协程

协程是单线程下，用户态的并发。英文名Coroutine，又称微线程，纤程。    
早期Python通过`yield`，`.send()`提供了对协程的基本支持，但是不完全。    
在python中，由于GIL锁的存在，并发编程的最佳实践是**多进程**+**协程**的方式。



## greenlet模块

第三方模块`greenlet`已经实现了协程，无需写生成器，`.switch()`代替了`.send()`。

```python
from greenlet import greenlet

def eat(name):
    print('%s eat 1' %name)
    g2.switch('egon')
    print('%s eat 2' %name)
    g2.switch()
def play(name):
    print('%s play 1' %name)
    g1.switch()
    print('%s play 2' %name)

g1=greenlet(eat)
g2=greenlet(play)

g1.switch('egon') # 可以在第一次switch时传入参数，以后都不需要
```



## gevent模块

第三方库`gevent`实现并发同步或异步编程，内部以`greenlet`方式**自动调度它自己的IO**，它是以C扩展模块形式接入Python的轻量级协程。是python2版本协程的首选方案。它的API与进程，线程相近。

```python
import gevent

g1=gevent.spawn(func,2,3,x=4,y=5)
g2=gevent.spawn(func2)

g1.join() #等待g1结束
g2.join() #等待g2结束
#或者上述两步合作一步：gevent.joinall([g1,g2])

print(g1.value) #拿到func1的返回值
```

它自己的IO有：`gevent.sleep()`，`gevent.socket`等

### 猴子补丁

```python
from gevent import spawn,joinall,monkey;monkey.patch_all()
```

在它之后导入的模块将被替换为它自己的io，动态替换已有的标准库。



## 其他第三方异步库

`eventlet`：同`gevent`模块，内部以`greenlet`方式，也有猴子补丁方法，但没`gevent`好用。    
`twisted`：基于事件驱动的网络引擎框架。    
`tornado`：最简单的回调实现异步协程，作为httpserver和httpclient，同时也是Web框架。



## asyncio模块

[`asyncio`](https://docs.python.org/zh-cn/3/library/asyncio.html)是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。

**可等待对象**(以下简写为aw)，包括：

- coroutine：协程对象，`async`关键字定义的函数对象
- task：任务对象，包含协程对象的各种状态
- future：task的父类，给予高层去等待 类似于js的promise

**简单运行和休眠事件循环**

- `asyncio.run(aw)`  创建和运行当前线程的loop
- `asyncio.sleep(秒数)`  模拟io耗时

### 创建事件循环

#### 最简单的运行

`asyncio.run(aw)`

```python
import asyncio

async def say(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    await say(1, 'hello')
    await say(2, 'world')

asyncio.run(main())
```

它将会打印 "start"，    
等待 1 秒，再打印 "hello"    
等待 2 秒，再打印 "world"    

由于没有注册为Task对象 await coroutine()代码依然是同步执行的。

`asyncio.run(main())`是 python3.7以上的写法    
以前的写法如下，只能先创建loop对象再使用loop上的方法。

```python
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main())
finally:
    loop.close()
```

#### 其他方法创建，获取和设置事件循环

- asyncio.get_running_loop()    
- asyncio.get_event_loop()    获取当前上下文的事件循环
- asyncio.set_event_loop(loop)
- asyncio.new_event_loop()    一般是给新线程使用，见下



### 创建Future或Task

#### `asyncio.create_task(aw)`

最简单的注册task

将协程对象及其各种状态打包注册为 Task 对象，放入任务队列中，并返回。

`asyncio.create_task()`是 python3.7以上的写法，以前只能用`asyncio.ensure_future()`和`loop.create_task()`

```python
#替代上文的main
async def main():
    task1 = asyncio.create_task(say(1, 'hello'))
    task2 = asyncio.create_task(say(2, 'world'))
    await task1
    await task2
```

它将会等待 1 秒，打印 "hello" ；等待 1 秒，再打印 "world"    
它们并发运行了。

::: warning await task
必须全部注册为task之后再await，否则依然是同步执行的
:::



#### `asyncio.gather(*aws)`

多个task或者coroutine整合为一个task

有返回值时，可获得顺序同aws的返回值列表

#### `asyncio.as_completed(aws)`

返回一个 task迭代器

```python
async def count(m):
    await asyncio.sleep(3)
    return m
async def main():
    tasks = [count(i) for i in range(10)]
    for task in asyncio.as_completed(tasks):
        result = await task
        print(result)
asyncio.run(main())
```



### 上下文管理

实现了`__aenter__` 和`__aexit__`。这两个方法都返回一个 awaitable类型的值。

和常规的with表达式一样，可以在一个async with表达式中指定多个上下文管理器。

```python
import aiohttp
async def get_page_html(url, head):
    async with aiohttp.ClientSession() as session:
        async with session.get(url=url, headers=head) as response:
            page_html = await response.text()
```



### loop对象方法

记得把loop对象传进main中以便操作loop方法

- loop.run_until_complete(future)。运行事件循环，直到future运行结束
- loop.run_forever()    表示事件循环会一直运行，直到遇到stop。
- loop.stop()。停止事件循环
- loop.is_running()。如果事件循环依然在运行，则返回True
- loop.is_closed()。如果事件循环已经close，则返回True
- loop.close()。关闭事件循环
- loop.time()。事件循环的时钟
- loop.create_future(coroutine) ，返回future对象
- loop.create_task(corootine) ，返回task对象
- loop.run_in_executor(executor, work)    连接线程池实现同步任务异步执行
  executor是concurrent.futures.ThreadPoolExecutor的实例对象
-   callback（只接受位置参数，）
    - `loop.call_later(delay, callback, *args, context=None)`
      延迟回调
    - `loop.call_at(when, callback, *args, context=None)`
      时刻点回调 结合loop.time()使用
    - `loop.call_soon(callback, *args, context=None)`
      下一个循环立即回调
    - `loop.call_soon_threadsafe(async callback, *args, context=None)`
      下一个循环立即回调，必须在另一个线程中使用

在新线程中使用loop.run_forever()使其**永远等待主线程向其发射task**

```python
import asyncio,aiohttp,re
from threading import Thread

header = {
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.67'
}

def start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

async def end_loop():
    loop = asyncio.get_event_loop()
    loop.stop()

async def get_title(url):
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url=url, headers=header) as response:
                page_text = await response.text()
                if title := re.search(r'(?<=\<title\>).*?(?=\</title\>)', page_text):
                    print(f'{url}: 解析网页标题为 {title.group()}')
                else:
                    print(f'{url}: 解析不到网页标题')
    except Exception as e:
        print(f'{url}: {e}')

new_loop = asyncio.new_event_loop()
t = Thread(target=start_loop, args=(new_loop,))
t.start()
while 1:
    new_loop.call_soon(print,'请输入完整url如https://t.com')
    ipt = input()
    if ipt == 'q':
        asyncio.run_coroutine_threadsafe(end_loop(),new_loop)
        break
    else:
        asyncio.run_coroutine_threadsafe(get_title(input()),new_loop)
t.join()
```



### task对象方法

- `.cancel()`	取消任务
- `.result()`    获取返回
- `.add_done_callback()` 添加完成时回调

### task规划
- `asyncio.wait_for(aw, timeout)`
超时抛出异常
- `asyncio.wait(tasks, return_when)`
阻塞等待所传tasks执行完毕 执行完毕可设置为任一完毕 任一异常 全部完毕

```python
import asyncio

async def count(m):
    await asyncio.sleep(2)
    return m

async def main():
    tasks = [count(i) for i in range(10)]
    done, pending = await asyncio.wait(tasks)
    for i in done:
        print(i.result())
asyncio.run(main())
```

return_when 指定此函数应在何时返回。它必须为以下常数之一:

| 常数              | 描述                                                       |
| :---------------- | :--------------------------------------------------------- |
| `FIRST_COMPLETED` | 任一完毕                                                   |
| `FIRST_EXCEPTION` | 任一异常。当没有引发任何异常时它就相当于 `ALL_COMPLETED`。 |
| `ALL_COMPLETED`   | 默认。全部完毕                                             |

与 `wait_for()`，`wait()` 在超时发生时不会取消可等待对象。

`asyncio.all_tasks()`

返回事件循环所运行的未完成的Task对象的集合

```python
for task in asyncio.all_tasks():
    print(task.cancel())
```

