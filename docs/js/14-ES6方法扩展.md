# ES6的方法拓展

## 字符串的拓展

### `.includes()`

检查传入的字符串是否在原来的字符串中。返回布尔值

```js
let str = "qwerdf";
str.includes("er");// true
str.includes("qer");//false
```

### `.startWith()`

检查是不是以传入字符串开始

```js
let str = "qwert";
str.starWith("q");//true
str.starWith("s");//false
```

### `.endWith()`

 检查是不是以传入字符串结束

```js
let str = "qwert";
str.endWith("t");//true
str.endWith("s");//false
```

### `.repeat()` 

返回一个字符串，重复传入数值的次数

```js
"ha".repeat(5);//"hahahahaha"
"哈".repeat(0);//""
```



## 数字的拓展

### `Number.parseInt()` 

取整 es6中被置于`Number`对象上（**静态方法**），原全局函数依然存在

```js
parseInt==Number.parseInt//true
```

### `Number.parseFloat()` 

取浮点数并去掉单位 es6中被置于`Number`对象上，原全局函数依然存在

```js
Number.parseFloat==parseFloat;//true
```

### `Number.isNaN()` 

严格判断是不是`NaN`

```js
isNaN(undefined);//true
Number.isNaN(undefined);//false
```

### `Number.isIntrger()` 

判断是否是整数

### 关于取整：

Number对象方法：`.toFixed(n)` 保留小数点后n位数，五舍六入，低版本IE也支持    
Math对象静态方法：`round(f)` `ceil(f)` `floor(f)` `rinc(f)`    
全局/Number对象静态方法：`parseInt(f)`    
位运算符组合： `~~f`  `f|0`  只针对正数



## 数组的拓展

### `Array.from()`

构造函数的方法，将传入的类数组转换为真正数组

```js
Array.from(document.querySelectorAll("div"))//NodeList对象转数组
Array.from(document.getElementsByTagName("div"))//HTMLCollection对象转数组
function foo(){
    let arg = Array.from(...arguments)//arguments对象
}
```

参数：

​	第一个参数：类数组对象    
​	第二个参数：生成数组传入每个参数进行的操作，回调函数，接受一个参数就是传入参数的本身    
​	第三个参数: 指定第二个回调函数内部的this的指向	

### `Array.of()` 

构造函数的方法，将一组数值转数组    
主要是统一操作的含义

```js
//原Array功能
Array(); //[]
Array(2);//[empty × 2]   这里歧义
Array(1, 2, 3);//[1, 2, 3]
//Array.of方法统一了操作
Array.of();//[]
Array.of(3);//[3]
Array.of(1, 2, 3);//[1, 2, 3]
```

### `.every()` 

对每一个项判断，都满足返回`true`，接受一个回调函数(以参数形式传入的函数，此函数依次接收数组每一项作为参数，返回true/false)

```js
let arr = [1,2,4];
arr.every(function(i){
    return i>0
})//true 返回一个结果，对1，2，4判断，都大于0就返回true
//等价写法
arr.every(i=>i>0);//true 用箭头函数返回
```

### `.filter()`

将数组中的元素进行筛选，满足条件的元素以数组的形式返回。**原数组不变**，传入l两个参数第一个函数，函数接受三个参数

- 第一个，传入的每一个元素，
- 第二个，传入的每一个元素的下标
- 第三个，数组的本身


函数返回一个布尔值

第二个后面的参数是函数执行时this指向的对象

```js
let arr = [1, 3, 2, 23, 135, 43, 5, 34, 45];
arr.filter(function(item,index,thiarr){
    return item>10
});//[23, 135, 43, 34, 45] 返回值大于10的数形成数组
arr.filter((item,index,thisarr)=>index>5);
//[5, 34, 45] //返回序号大于5的元素形成的数组
```

### `.forEach()`

 对数组每个元素执行对应的操作，参数类型和filter一致,返回undefined

```js
let arr = [
    function(){console.log("1"+this.name)},    
    function(){console.log("2"+this.name)},   
];
let obj = {
    name: "this obj"
}
arr.forEach(function(item){
    item.call(this)
},obj);//打印"1this obj" "2this obj" 
```

### `.map()`

 将数组中的每一项进行操作，然后返回，**改变原数组**，格式和`filter`一致

```js
const arr = [1,2,3,4,5];
arr.map((i)=>6-i);//[5, 4, 3, 2, 1]
```

### `.reduce()`

 将数组的每一个值迭代起来，然后返回迭代结果。

```js
let arr = [1,2,3,4]
arr.reduce((a,b)=>a+b)//10 此时将每一个加起来
arr.reduce((a,b)=>a+b,3)//13 3作为叠加的第一项
arr.reduce((a,b)=>a+b,"")//"1234" ""作为叠加的第一项
```

将数组每一个元素叠加处理，转换合并再输出，**不改变原数组**

`reduce`接受两个参数，第一个是回调函数，回调函数接受四个参数

- 第一个： 累加的载体
- 第二个： 当前值
- 第三个： 当前索引
- 第四个： 数组本身

第二个参数时回调函数的主体对象

一行代码统计字符串中的相同字母的个数

```js
"asdasdzxczxcaasdasd".split("").reduce((x,y)=>(x[y]?x[y]++:x[y]=1,x),{})
```

逗号运算符再表达式中的意义： 表达式会返回逗号后面的值。



## 对象的拓展

### 属性名值合并

```js
function createObj(x, y){
    return {x, y}//等价于return {x: x, y: y}
}
let o = createObj(1, 3);//{x: 1, y: 3}
```

### `get`  `set` 关键字

对象中的`get`与`set`方法，获取元素的值和设置值的不同操作。

```js
let o = {
    _value: 10,//加_表示不必建议访问
    get value(){//获取值或进行的操作。
        return this._value++
    },
    set value(val){//设置值会进行的操作
        this._value-=val;
    }
}
o.value;//10
o.value;//11
o.value = 3;//此时o._value已经从12减3了
o.value;//9 此时o._value已经编程10了
```

### `Object.is()`

ES5比较相等有`==`和`===`两种，前者会隐式类型转换，后者对于特殊情况比较结果反直觉

比如： 

```js
+0 === -0//true
NaN === NaN//false
//而
Object.is(+0, -0)//false
Object.is(NaN, NaN)//true
```

### `Object.keys()`

返回对象的所有可枚举**属性名**的数组

```js
let obj = {a:1,b:2,c:3}
Object.keys(obj)//["a", "b", "c"]
```

### `Object.values()` 和`Object.entries()`

返回可枚举的值或者键值对的数组

```js
const {keys, values, entries} = Object
let obj = {a:1,b:2,c:3}
values(obj)//[1, 2, 3]
for(let [key, value] of entries(obj)){
    console.log([key,value])
}
```

### `Object.assign()` 

复制可枚举属性到目标对象上。返回目标对象

第一个参数是目标对象    
第二个以及以后的参数是要复制属性的对象

```js
let target = {a: 1},
    o1 = {a: 2, b: 2},
    o2 = {b: 3, c: 4};
Object.assign(target,o1,o2);
//{a: 2, b: 3, c: 4},后面的相同的属性会把前面的属性覆盖掉
Object.assign(target) === target;//true
Object.assign({},"asd");//{0: "a", 1: "s", 2: "d"} "asd"会以string对象的形式传进去
```

使用：简化代码书写，添加属性

```js
function Foo(name, value, x, y, vx, vy){构造函数
    this.name = name;
    //...很长
}
//使用assign
function Foo(name, value, x, y, vx, vy){
    Object.assign(this,{name, value, x, y, vx, vy});
}
new Foo("name","yinshi",100,200,2,3);//...
```

原型添加方法（归档在此处，学完面向对象请后再来查阅）

```js
function Foo(){}
Object.assign(Foo.prototype ,{
    say(){
        //..
    },
    dance(){
        
    }
}
```

### `Object.defineProperty()`

不直接用`.`或者`[]`的写法，对对象的属性添加和修改（劫持）

需要传入3个参数：

1. obj：要在其上定义属性的对象。
2. prop：要定义或修改的属性的名称。
3. descriptor：将被定义或修改的属性描述符。

#### descriptor对象的可定义的属性：

* 值（value）

* 值可修改性（writable）

  属性值是否可以修改，改成false就是不可以修改

* 可枚举性（enumerable）

  属性值是否可以枚举，当我们挨个访问属性值的时候可以访问得到与否

* 属性特点可修改性（configurable）

  上述属性的特点是可以修改改的，如果设置false，则上述可修改可枚举以及本身都不可以修改了，相当于被直接冻结

##### value和writable

```js
let a = {
    like: "food",
    name: "Gin",
}
Object.defineProperty(a,"like",{
    value: "goods",
    writable: false,
});
console.log(a.like);//goods
a.like = "123";
console.log(a.like); //goods
```

##### enumerable

可枚举指的是是否能够被`for……in`或者`Object.keys`遍历到，默认为`true`

```js
let a = {
    like: "food",
    name: "Gin",
}
Object.defineProperty(a,"like",{
    value: "goods",
    writable: false,
    enumerable: false,
});
for(i in a){console.log(i)};//"name"
Object.keys(a)//["name"]
```

注意：

给数组元素设置`enumerable: false`可以不被上文的两种方法遍历到，    
但是能被`for...of`遍历到，因为它依然是生成器中的一个键。

##### get和set

在对属性操作(获取，修改)的时候会触发的操作，    
不能 **同时**设置访问器 (`get` 和`set`) 和`wriable` 或 `value`

```js
let a = {}
Object.defineProperty(a,"like",{
    get: (function(){
      	var t = 0;
        return function(){
        	return t++
    	}
    })(),
}); 
//每次访问就会增加1，从0开始，并且不可修改
```

```js
let a = {};
Object.defineProperty(a,"like",{
    get: function(){
    	return this._t;
	},
    set: function(newValue){
		console.log("你正在设置like的值");	
        return this._t = newValue;
    },
}); 
a.like = 2 //"你正在设置like的值"
console.log(a.like);
```

它可以帮助我们实现数据变动的监听。但是存在一个可以访问的私有变量。    
Vue2的双向数据绑定的原理就是借助这个方法。

### `Object.freeze()`

对对象进行**浅冻结**，使其再也不能被修改。

```js
const obj = {
  prop: 42
};

Object.freeze(obj);

obj.prop = 33;
// Throws an error in strict mode
```

但是其内部的引用类型数据依然可以被修改






