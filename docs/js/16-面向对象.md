# 面向对象

对象的创建有两种字面量和构造函数

```js
let obj = {};//字面量
obj = new Object;//构造函数
```

两种方法的本质是一样的，都是新建了一个对象赋值给了obj，

如果我们每使用一次都会创建一个对象。那么就会生成大量重复的对象。并且每次生成的时候包括方法在内都会重复。

可以利用JavaScript的原型的特点，来构造出一个包含共同方法和私有属性的对象。这个特性就是JS对象的原型。



## 原型

### new

构造函数生成实例化对象的方式是new关键字。

内部用this指代需要生成的实例化对象，添加属性与方法。

构造函数函数名通常首字母大写。

```js
function Person(name){
    this.name = name;
    this.say = function(){
        console.log(this.name)
    }
}
let p1 = new Person("Gintama");
p1;//{name: "Gintama",say:function(){console.log(this.name)}}
p1.say();//"Gintama"
```

原本JavaScript是没有类的，只有基于原型，在构造函数中通过new关键字可以生成对象，和基于类的语言非常类似，所以我们称构造函数也是一个类。

### prototype

只有(构造)函数 原型prototype对象，可以直接访问修改原型的属性，

原型对象的方法可以让实例化对象使用

```js
function Person(name){
    this.name = name;
}
Person.prototype.say = function(){//注意，一定要写在实例化之前，这是赋值
    console.log(this.name)
}
let p1 = new Person("Gintama");
let p2 = new Person("狗蛋")；
p1.say();//"Gintama"
p2.say();//"狗蛋"
Person.prototype.say = function(){//注意，一定要写在实例化之前，这是赋值
    console.log("shut up!")
}
p1.say();//"shut up!"
```

### `__proto__ `

任何（实例化）对象拥有一个属性constructor，构造器。它指向当前对象的构造函数。

```js
function Person(){}
let p = new Person();
p.constructor === Person;//true
let o1 = {};
o1.constructor === Object;//true
```

函数也是一个对象，也有构造函数

```js
Person.constructor === Function;//true
Function.constructor === Function;//true
Object.constructor === Function;//true
```

实例化对象拥有隐式原型`[[prototype]]`，可以通过 `__proto__` 访问构造函数的原型

(实际上有的浏览器不支持这个属性)。推荐使用`Object.getPrototypeOf()`访问。

```js
//手动写一个__proto__属性，如果没有的话
Object.defineProperty(Object.prototype,"__proto__",{
    get: function(){
        return Object.getPrototypeOf(this)
    },
    set: function(o){
        Object.setPrototypeOf(this, o)
        return o
    }
})
```

实例化对象的隐式原型指向其构造函数的prototype，这样就直接的访问了构造函数的方法属性

```js
function Person(){}
let p = new Person();
p.__proto__ === Object.getPrototypeOf(p);//true
```

```js
let o1 = new Object();
let o2 = {};
function Foo(){};
let fo1 = new Foo();
o1.__proto__ === Object.prototype;//true
fo1.__proto__ === Foo.prototype;//true
```

于是，实例化对象和构造函数关联到一起了。通过 `__proto__` 可以访问到构造函数原型的方法。

```js
function Foo(){
    this.name = "Foo构造函数"
}
Foo.prototype.say = function(){
    console.log(this.name);
}
let fo1 = new Foo();
fo1.say();//函数存在并执行，访问了fo1构造函数原型上的方法
```

**new关键字做了什么**

```js
function Foo(){}
//let o = new Foo();等价于做了以下
o = new Foo();//新建一个对象，此时o.__protot__ === Object.prototype
o.__proto__ = Foo.prototype;//修改对象原型指向
Foo.call(o);//将this指向o执行
```

构造函数Object的原型对象的构造器是他自己

```js
Object.prototype.constructor === Object;//true
```

### instanceof

 判断是否是实例或子类

```js
p1 instanceof Person;//true
```

Object是对象，同时也是构造函数。（可以使用new Object）

```js
Object instanceof Object;//true
Object instanceof Function;//true
```

因此，**任何的对象都是可以看作Object的实例。**





## 寄生继承

继承我们主要要干几件事：

- 把父类的属性和方法想办法绑定到子类上
- 把父类添加到子类的原型链上

子类与父类之间的继承关系，和实例与类下关系差不多。

```js
function inheritPrototype(subType, superType) {
    var prototype = object(superType.prototype); // 创建对象
    prototype.constructor = subType; // 增强对象
    subType.prototype = prototype; // 指定对象
}
```



## ES6 class

es6新语法糖，构造函数和继承方法细节隐藏，但是很直白

声明使用class关键字 也可以使用匿名class表达式 

```js
class Rectangle {
    // constructor
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
    // Getter
    get area() {
        return this.calcArea()
    }
    // Method
    calcArea() {
        return this.height * this.width;
    }
}
const square = new Rectangle(10, 10);

console.log(square.area);
// 100
```

上式结构分明，一目了然。要注意没有逗号

### extends

继承。class 子类 extends 父类

**super**指代超类，顺着`__proto__`查找超类。

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // 调用超类构造函数并传入name参数
  }
  speak() {
    console.log(`${this.name} barks.`);
  }
}

var d = new Dog('Mitzie');
d.speak();// 'Mitzie barks.'

```

### static

定义一个类的一个静态方法，调用静态方法不需要实例化。方法中也不使用this

```js
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    static displayName = "Point";
    static distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy);
    }
}
```

### `Symbol.species`

覆盖默认的构造函数

```js
class MyArray extends Array {
  // Overwrite species to the parent Array constructor
  static get [Symbol.species]() { return Array; }
}
var a = new MyArray(1,2,3);
var mapped = a.map(x => x * x);

console.log(mapped instanceof MyArray);
// false
console.log(mapped instanceof Array);
// true
```

### private

私有。相当于类中的局部变量。（ts用private，js用#属性名）

```js
class Rectangle {
  #height = 0;
  #width;
  constructor(height, width) {
    this.#height = height;
    this.#width = width;
  }
}
```




## 包装对象

字面量：数值和字符串和布尔值他们本质上也是实例对象，但是看上去是字面量，却又可以使用对象的方法。

```js
(2).toString();//"2"
```

能够像对象一样进行属性设置操作，这是因为这行代码执行时临时生成了一个包装对象

Number(2)并对它进行操作返回值，然后销毁。

```js
"123"*1;//123
//本质上是
Number("123").valueOf()*1;//123
let str = "asd"
str.length;//3
//本质上是
String(str).length;//3
str.length = 4;
str.length;//3
```

这就是为什么这里只能访问str的值却无法修改的原因了，因为**每次都会生成一个新的包装对象**
